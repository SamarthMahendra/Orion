// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: orion.proto
// Protobuf C++ Version: 6.33.4

#ifndef orion_2eproto_2epb_2eh
#define orion_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033004
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_orion_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_orion_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_orion_2eproto;
}  // extern "C"
namespace orion {
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Empty_class_data_;
class ObjectData;
struct ObjectDataDefaultTypeInternal;
extern ObjectDataDefaultTypeInternal _ObjectData_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ObjectData_class_data_;
class ObjectLocationReply;
struct ObjectLocationReplyDefaultTypeInternal;
extern ObjectLocationReplyDefaultTypeInternal _ObjectLocationReply_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ObjectLocationReply_class_data_;
class ObjectLocationRequest;
struct ObjectLocationRequestDefaultTypeInternal;
extern ObjectLocationRequestDefaultTypeInternal _ObjectLocationRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ObjectLocationRequest_class_data_;
class ObjectReport;
struct ObjectReportDefaultTypeInternal;
extern ObjectReportDefaultTypeInternal _ObjectReport_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ObjectReport_class_data_;
class RegisterNodeReply;
struct RegisterNodeReplyDefaultTypeInternal;
extern RegisterNodeReplyDefaultTypeInternal _RegisterNodeReply_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegisterNodeReply_class_data_;
class RegisterNodeRequest;
struct RegisterNodeRequestDefaultTypeInternal;
extern RegisterNodeRequestDefaultTypeInternal _RegisterNodeRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegisterNodeRequest_class_data_;
class TaskReply;
struct TaskReplyDefaultTypeInternal;
extern TaskReplyDefaultTypeInternal _TaskReply_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TaskReply_class_data_;
class TaskRequest;
struct TaskRequestDefaultTypeInternal;
extern TaskRequestDefaultTypeInternal _TaskRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TaskRequest_class_data_;
}  // namespace orion
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace orion {

// ===================================================================


// -------------------------------------------------------------------

class TaskRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:orion.TaskRequest) */ {
 public:
  inline TaskRequest() : TaskRequest(nullptr) {}
  ~TaskRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TaskRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TaskRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskRequest(::google::protobuf::internal::ConstantInitialized);

  inline TaskRequest(const TaskRequest& from) : TaskRequest(nullptr, from) {}
  inline TaskRequest(TaskRequest&& from) noexcept
      : TaskRequest(nullptr, ::std::move(from)) {}
  inline TaskRequest& operator=(const TaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskRequest& operator=(TaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskRequest& default_instance() {
    return *reinterpret_cast<const TaskRequest*>(
        &_TaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(TaskRequest& a, TaskRequest& b) { a.Swap(&b); }
  inline void Swap(TaskRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TaskRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskRequest& from) { TaskRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TaskRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "orion.TaskRequest"; }

  explicit TaskRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TaskRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TaskRequest& from);
  TaskRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TaskRequest&& from) noexcept
      : TaskRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDepIdsFieldNumber = 2,
    kArgsFieldNumber = 4,
    kTaskIdFieldNumber = 1,
    kFunctionNameFieldNumber = 3,
  };
  // repeated string dep_ids = 2;
  int dep_ids_size() const;
  private:
  int _internal_dep_ids_size() const;

  public:
  void clear_dep_ids() ;
  const ::std::string& dep_ids(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_dep_ids(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_dep_ids(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_dep_ids();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_dep_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& dep_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_dep_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_dep_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_dep_ids();

  public:
  // repeated bytes args = 4;
  int args_size() const;
  private:
  int _internal_args_size() const;

  public:
  void clear_args() ;
  const ::std::string& args(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_args(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_args(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_args();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_args(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& args() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_args();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_args() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_args();

  public:
  // string task_id = 1;
  void clear_task_id() ;
  const ::std::string& task_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_task_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_task_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_task_id();
  void set_allocated_task_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_task_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_task_id();

  public:
  // string function_name = 3;
  void clear_function_name() ;
  const ::std::string& function_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_function_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_function_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_function_name();
  void set_allocated_function_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_function_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_function_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_function_name();

  public:
  // @@protoc_insertion_point(class_scope:orion.TaskRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 53,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TaskRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> dep_ids_;
    ::google::protobuf::RepeatedPtrField<::std::string> args_;
    ::google::protobuf::internal::ArenaStringPtr task_id_;
    ::google::protobuf::internal::ArenaStringPtr function_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_orion_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TaskRequest_class_data_;
// -------------------------------------------------------------------

class TaskReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:orion.TaskReply) */ {
 public:
  inline TaskReply() : TaskReply(nullptr) {}
  ~TaskReply() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TaskReply* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TaskReply));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskReply(::google::protobuf::internal::ConstantInitialized);

  inline TaskReply(const TaskReply& from) : TaskReply(nullptr, from) {}
  inline TaskReply(TaskReply&& from) noexcept
      : TaskReply(nullptr, ::std::move(from)) {}
  inline TaskReply& operator=(const TaskReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskReply& operator=(TaskReply&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskReply& default_instance() {
    return *reinterpret_cast<const TaskReply*>(
        &_TaskReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(TaskReply& a, TaskReply& b) { a.Swap(&b); }
  inline void Swap(TaskReply* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskReply* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskReply* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TaskReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskReply& from) { TaskReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TaskReply* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "orion.TaskReply"; }

  explicit TaskReply(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TaskReply(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TaskReply& from);
  TaskReply(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TaskReply&& from) noexcept
      : TaskReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeIdFieldNumber = 2,
    kAcceptedFieldNumber = 1,
  };
  // string node_id = 2;
  void clear_node_id() ;
  const ::std::string& node_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_node_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_node_id();
  void set_allocated_node_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_node_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_node_id();

  public:
  // bool accepted = 1;
  void clear_accepted() ;
  bool accepted() const;
  void set_accepted(bool value);

  private:
  bool _internal_accepted() const;
  void _internal_set_accepted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:orion.TaskReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 31,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TaskReply& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr node_id_;
    bool accepted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_orion_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TaskReply_class_data_;
// -------------------------------------------------------------------

class RegisterNodeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:orion.RegisterNodeRequest) */ {
 public:
  inline RegisterNodeRequest() : RegisterNodeRequest(nullptr) {}
  ~RegisterNodeRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegisterNodeRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegisterNodeRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterNodeRequest(::google::protobuf::internal::ConstantInitialized);

  inline RegisterNodeRequest(const RegisterNodeRequest& from) : RegisterNodeRequest(nullptr, from) {}
  inline RegisterNodeRequest(RegisterNodeRequest&& from) noexcept
      : RegisterNodeRequest(nullptr, ::std::move(from)) {}
  inline RegisterNodeRequest& operator=(const RegisterNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterNodeRequest& operator=(RegisterNodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterNodeRequest& default_instance() {
    return *reinterpret_cast<const RegisterNodeRequest*>(
        &_RegisterNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(RegisterNodeRequest& a, RegisterNodeRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterNodeRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterNodeRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterNodeRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegisterNodeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterNodeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterNodeRequest& from) { RegisterNodeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegisterNodeRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "orion.RegisterNodeRequest"; }

  explicit RegisterNodeRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegisterNodeRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegisterNodeRequest& from);
  RegisterNodeRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegisterNodeRequest&& from) noexcept
      : RegisterNodeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeIdFieldNumber = 1,
    kAddressFieldNumber = 2,
  };
  // string node_id = 1;
  void clear_node_id() ;
  const ::std::string& node_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_node_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_node_id();
  void set_allocated_node_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_node_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_node_id();

  public:
  // string address = 2;
  void clear_address() ;
  const ::std::string& address() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_address();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_address();
  void set_allocated_address(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_address() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_address(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:orion.RegisterNodeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 48,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegisterNodeRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr node_id_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_orion_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegisterNodeRequest_class_data_;
// -------------------------------------------------------------------

class RegisterNodeReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:orion.RegisterNodeReply) */ {
 public:
  inline RegisterNodeReply() : RegisterNodeReply(nullptr) {}
  ~RegisterNodeReply() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegisterNodeReply* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegisterNodeReply));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterNodeReply(::google::protobuf::internal::ConstantInitialized);

  inline RegisterNodeReply(const RegisterNodeReply& from) : RegisterNodeReply(nullptr, from) {}
  inline RegisterNodeReply(RegisterNodeReply&& from) noexcept
      : RegisterNodeReply(nullptr, ::std::move(from)) {}
  inline RegisterNodeReply& operator=(const RegisterNodeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterNodeReply& operator=(RegisterNodeReply&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterNodeReply& default_instance() {
    return *reinterpret_cast<const RegisterNodeReply*>(
        &_RegisterNodeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(RegisterNodeReply& a, RegisterNodeReply& b) { a.Swap(&b); }
  inline void Swap(RegisterNodeReply* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterNodeReply* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterNodeReply* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegisterNodeReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterNodeReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterNodeReply& from) { RegisterNodeReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegisterNodeReply* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "orion.RegisterNodeReply"; }

  explicit RegisterNodeReply(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegisterNodeReply(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegisterNodeReply& from);
  RegisterNodeReply(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegisterNodeReply&& from) noexcept
      : RegisterNodeReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:orion.RegisterNodeReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegisterNodeReply& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_orion_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegisterNodeReply_class_data_;
// -------------------------------------------------------------------

class ObjectReport final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:orion.ObjectReport) */ {
 public:
  inline ObjectReport() : ObjectReport(nullptr) {}
  ~ObjectReport() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ObjectReport* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ObjectReport));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectReport(::google::protobuf::internal::ConstantInitialized);

  inline ObjectReport(const ObjectReport& from) : ObjectReport(nullptr, from) {}
  inline ObjectReport(ObjectReport&& from) noexcept
      : ObjectReport(nullptr, ::std::move(from)) {}
  inline ObjectReport& operator=(const ObjectReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectReport& operator=(ObjectReport&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectReport& default_instance() {
    return *reinterpret_cast<const ObjectReport*>(
        &_ObjectReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ObjectReport& a, ObjectReport& b) { a.Swap(&b); }
  inline void Swap(ObjectReport* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectReport* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectReport* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ObjectReport>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectReport& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectReport& from) { ObjectReport::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ObjectReport* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "orion.ObjectReport"; }

  explicit ObjectReport(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ObjectReport(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ObjectReport& from);
  ObjectReport(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ObjectReport&& from) noexcept
      : ObjectReport(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectIdFieldNumber = 1,
    kNodeIdFieldNumber = 2,
  };
  // string object_id = 1;
  void clear_object_id() ;
  const ::std::string& object_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_object_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_object_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_object_id();
  void set_allocated_object_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_object_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_object_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_object_id();

  public:
  // string node_id = 2;
  void clear_node_id() ;
  const ::std::string& node_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_node_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_node_id();
  void set_allocated_node_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_node_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_node_id();

  public:
  // @@protoc_insertion_point(class_scope:orion.ObjectReport)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 43,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ObjectReport& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr object_id_;
    ::google::protobuf::internal::ArenaStringPtr node_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_orion_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ObjectReport_class_data_;
// -------------------------------------------------------------------

class ObjectLocationRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:orion.ObjectLocationRequest) */ {
 public:
  inline ObjectLocationRequest() : ObjectLocationRequest(nullptr) {}
  ~ObjectLocationRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ObjectLocationRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ObjectLocationRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectLocationRequest(::google::protobuf::internal::ConstantInitialized);

  inline ObjectLocationRequest(const ObjectLocationRequest& from) : ObjectLocationRequest(nullptr, from) {}
  inline ObjectLocationRequest(ObjectLocationRequest&& from) noexcept
      : ObjectLocationRequest(nullptr, ::std::move(from)) {}
  inline ObjectLocationRequest& operator=(const ObjectLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectLocationRequest& operator=(ObjectLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectLocationRequest& default_instance() {
    return *reinterpret_cast<const ObjectLocationRequest*>(
        &_ObjectLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ObjectLocationRequest& a, ObjectLocationRequest& b) { a.Swap(&b); }
  inline void Swap(ObjectLocationRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectLocationRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectLocationRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ObjectLocationRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectLocationRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectLocationRequest& from) { ObjectLocationRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ObjectLocationRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "orion.ObjectLocationRequest"; }

  explicit ObjectLocationRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ObjectLocationRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ObjectLocationRequest& from);
  ObjectLocationRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ObjectLocationRequest&& from) noexcept
      : ObjectLocationRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectIdFieldNumber = 1,
  };
  // string object_id = 1;
  void clear_object_id() ;
  const ::std::string& object_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_object_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_object_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_object_id();
  void set_allocated_object_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_object_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_object_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_object_id();

  public:
  // @@protoc_insertion_point(class_scope:orion.ObjectLocationRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 45,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ObjectLocationRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr object_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_orion_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ObjectLocationRequest_class_data_;
// -------------------------------------------------------------------

class ObjectLocationReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:orion.ObjectLocationReply) */ {
 public:
  inline ObjectLocationReply() : ObjectLocationReply(nullptr) {}
  ~ObjectLocationReply() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ObjectLocationReply* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ObjectLocationReply));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectLocationReply(::google::protobuf::internal::ConstantInitialized);

  inline ObjectLocationReply(const ObjectLocationReply& from) : ObjectLocationReply(nullptr, from) {}
  inline ObjectLocationReply(ObjectLocationReply&& from) noexcept
      : ObjectLocationReply(nullptr, ::std::move(from)) {}
  inline ObjectLocationReply& operator=(const ObjectLocationReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectLocationReply& operator=(ObjectLocationReply&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectLocationReply& default_instance() {
    return *reinterpret_cast<const ObjectLocationReply*>(
        &_ObjectLocationReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ObjectLocationReply& a, ObjectLocationReply& b) { a.Swap(&b); }
  inline void Swap(ObjectLocationReply* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectLocationReply* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectLocationReply* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ObjectLocationReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectLocationReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectLocationReply& from) { ObjectLocationReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ObjectLocationReply* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "orion.ObjectLocationReply"; }

  explicit ObjectLocationReply(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ObjectLocationReply(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ObjectLocationReply& from);
  ObjectLocationReply(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ObjectLocationReply&& from) noexcept
      : ObjectLocationReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeIdFieldNumber = 1,
    kAddressFieldNumber = 2,
  };
  // string node_id = 1;
  void clear_node_id() ;
  const ::std::string& node_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_node_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_node_id();
  void set_allocated_node_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_node_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_node_id();

  public:
  // string address = 2;
  void clear_address() ;
  const ::std::string& address() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_address();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_address();
  void set_allocated_address(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_address() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_address(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:orion.ObjectLocationReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 48,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ObjectLocationReply& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr node_id_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_orion_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ObjectLocationReply_class_data_;
// -------------------------------------------------------------------

class ObjectData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:orion.ObjectData) */ {
 public:
  inline ObjectData() : ObjectData(nullptr) {}
  ~ObjectData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ObjectData* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ObjectData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectData(::google::protobuf::internal::ConstantInitialized);

  inline ObjectData(const ObjectData& from) : ObjectData(nullptr, from) {}
  inline ObjectData(ObjectData&& from) noexcept
      : ObjectData(nullptr, ::std::move(from)) {}
  inline ObjectData& operator=(const ObjectData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectData& operator=(ObjectData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectData& default_instance() {
    return *reinterpret_cast<const ObjectData*>(
        &_ObjectData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ObjectData& a, ObjectData& b) { a.Swap(&b); }
  inline void Swap(ObjectData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectData* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ObjectData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectData& from) { ObjectData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ObjectData* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "orion.ObjectData"; }

  explicit ObjectData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ObjectData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ObjectData& from);
  ObjectData(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ObjectData&& from) noexcept
      : ObjectData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectIdFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string object_id = 1;
  void clear_object_id() ;
  const ::std::string& object_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_object_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_object_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_object_id();
  void set_allocated_object_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_object_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_object_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_object_id();

  public:
  // bytes data = 2;
  void clear_data() ;
  const ::std::string& data() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_data();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_data();
  void set_allocated_data(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_data() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_data(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:orion.ObjectData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 34,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ObjectData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr object_id_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_orion_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ObjectData_class_data_;
// -------------------------------------------------------------------

class Empty final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:orion.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Empty* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Empty));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Empty(::google::protobuf::internal::ConstantInitialized);

  inline Empty(const Empty& from) : Empty(nullptr, from) {}
  inline Empty(Empty&& from) noexcept
      : Empty(nullptr, ::std::move(from)) {}
  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *reinterpret_cast<const Empty*>(
        &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Empty& a, Empty& b) { a.Swap(&b); }
  inline void Swap(Empty* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Empty>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "orion.Empty"; }

  explicit Empty(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Empty(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Empty& from);
  Empty(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Empty&& from) noexcept
      : Empty(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:orion.Empty)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_orion_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Empty_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RegisterNodeRequest

// string node_id = 1;
inline void RegisterNodeRequest::clear_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& RegisterNodeRequest::node_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:orion.RegisterNodeRequest.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RegisterNodeRequest::set_node_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:orion.RegisterNodeRequest.node_id)
}
inline ::std::string* PROTOBUF_NONNULL RegisterNodeRequest::mutable_node_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:orion.RegisterNodeRequest.node_id)
  return _s;
}
inline const ::std::string& RegisterNodeRequest::_internal_node_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_id_.Get();
}
inline void RegisterNodeRequest::_internal_set_node_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RegisterNodeRequest::_internal_mutable_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.node_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RegisterNodeRequest::release_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:orion.RegisterNodeRequest.node_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.node_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.node_id_.Set("", GetArena());
  }
  return released;
}
inline void RegisterNodeRequest::set_allocated_node_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.node_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.node_id_.IsDefault()) {
    _impl_.node_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.RegisterNodeRequest.node_id)
}

// string address = 2;
inline void RegisterNodeRequest::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& RegisterNodeRequest::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:orion.RegisterNodeRequest.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RegisterNodeRequest::set_address(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:orion.RegisterNodeRequest.address)
}
inline ::std::string* PROTOBUF_NONNULL RegisterNodeRequest::mutable_address()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:orion.RegisterNodeRequest.address)
  return _s;
}
inline const ::std::string& RegisterNodeRequest::_internal_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.address_.Get();
}
inline void RegisterNodeRequest::_internal_set_address(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RegisterNodeRequest::_internal_mutable_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.address_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RegisterNodeRequest::release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:orion.RegisterNodeRequest.address)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.address_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.address_.Set("", GetArena());
  }
  return released;
}
inline void RegisterNodeRequest::set_allocated_address(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.RegisterNodeRequest.address)
}

// -------------------------------------------------------------------

// RegisterNodeReply

// bool success = 1;
inline void RegisterNodeReply::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool RegisterNodeReply::success() const {
  // @@protoc_insertion_point(field_get:orion.RegisterNodeReply.success)
  return _internal_success();
}
inline void RegisterNodeReply::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:orion.RegisterNodeReply.success)
}
inline bool RegisterNodeReply::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void RegisterNodeReply::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// TaskRequest

// string task_id = 1;
inline void TaskRequest::clear_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& TaskRequest::task_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:orion.TaskRequest.task_id)
  return _internal_task_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TaskRequest::set_task_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:orion.TaskRequest.task_id)
}
inline ::std::string* PROTOBUF_NONNULL TaskRequest::mutable_task_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:orion.TaskRequest.task_id)
  return _s;
}
inline const ::std::string& TaskRequest::_internal_task_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_id_.Get();
}
inline void TaskRequest::_internal_set_task_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TaskRequest::_internal_mutable_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.task_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TaskRequest::release_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:orion.TaskRequest.task_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.task_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.task_id_.Set("", GetArena());
  }
  return released;
}
inline void TaskRequest::set_allocated_task_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.task_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.task_id_.IsDefault()) {
    _impl_.task_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.TaskRequest.task_id)
}

// repeated string dep_ids = 2;
inline int TaskRequest::_internal_dep_ids_size() const {
  return _internal_dep_ids().size();
}
inline int TaskRequest::dep_ids_size() const {
  return _internal_dep_ids_size();
}
inline void TaskRequest::clear_dep_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dep_ids_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL TaskRequest::add_dep_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_dep_ids()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:orion.TaskRequest.dep_ids)
  return _s;
}
inline const ::std::string& TaskRequest::dep_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:orion.TaskRequest.dep_ids)
  return _internal_dep_ids().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL TaskRequest::mutable_dep_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:orion.TaskRequest.dep_ids)
  return _internal_mutable_dep_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void TaskRequest::set_dep_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_dep_ids()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:orion.TaskRequest.dep_ids)
}
template <typename Arg_, typename... Args_>
inline void TaskRequest::add_dep_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_dep_ids(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:orion.TaskRequest.dep_ids)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& TaskRequest::dep_ids()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:orion.TaskRequest.dep_ids)
  return _internal_dep_ids();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
TaskRequest::mutable_dep_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:orion.TaskRequest.dep_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dep_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
TaskRequest::_internal_dep_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dep_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
TaskRequest::_internal_mutable_dep_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dep_ids_;
}

// string function_name = 3;
inline void TaskRequest::clear_function_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.function_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& TaskRequest::function_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:orion.TaskRequest.function_name)
  return _internal_function_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TaskRequest::set_function_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.function_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:orion.TaskRequest.function_name)
}
inline ::std::string* PROTOBUF_NONNULL TaskRequest::mutable_function_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_function_name();
  // @@protoc_insertion_point(field_mutable:orion.TaskRequest.function_name)
  return _s;
}
inline const ::std::string& TaskRequest::_internal_function_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.function_name_.Get();
}
inline void TaskRequest::_internal_set_function_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.function_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TaskRequest::_internal_mutable_function_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.function_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TaskRequest::release_function_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:orion.TaskRequest.function_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.function_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.function_name_.Set("", GetArena());
  }
  return released;
}
inline void TaskRequest::set_allocated_function_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.function_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.function_name_.IsDefault()) {
    _impl_.function_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.TaskRequest.function_name)
}

// repeated bytes args = 4;
inline int TaskRequest::_internal_args_size() const {
  return _internal_args().size();
}
inline int TaskRequest::args_size() const {
  return _internal_args_size();
}
inline void TaskRequest::clear_args() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.args_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::std::string* PROTOBUF_NONNULL TaskRequest::add_args()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_args()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add_mutable:orion.TaskRequest.args)
  return _s;
}
inline const ::std::string& TaskRequest::args(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:orion.TaskRequest.args)
  return _internal_args().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL TaskRequest::mutable_args(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:orion.TaskRequest.args)
  return _internal_mutable_args()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void TaskRequest::set_args(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_args()->Mutable(index), ::std::forward<Arg_>(value),
                        args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_set:orion.TaskRequest.args)
}
template <typename Arg_, typename... Args_>
inline void TaskRequest::add_args(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_args(), ::std::forward<Arg_>(value),
      args... , ::google::protobuf::internal::BytesTag{});
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:orion.TaskRequest.args)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& TaskRequest::args()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:orion.TaskRequest.args)
  return _internal_args();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
TaskRequest::mutable_args() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:orion.TaskRequest.args)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_args();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
TaskRequest::_internal_args() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.args_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
TaskRequest::_internal_mutable_args() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.args_;
}

// -------------------------------------------------------------------

// TaskReply

// bool accepted = 1;
inline void TaskReply::clear_accepted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.accepted_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool TaskReply::accepted() const {
  // @@protoc_insertion_point(field_get:orion.TaskReply.accepted)
  return _internal_accepted();
}
inline void TaskReply::set_accepted(bool value) {
  _internal_set_accepted(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:orion.TaskReply.accepted)
}
inline bool TaskReply::_internal_accepted() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.accepted_;
}
inline void TaskReply::_internal_set_accepted(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.accepted_ = value;
}

// string node_id = 2;
inline void TaskReply::clear_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& TaskReply::node_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:orion.TaskReply.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TaskReply::set_node_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:orion.TaskReply.node_id)
}
inline ::std::string* PROTOBUF_NONNULL TaskReply::mutable_node_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:orion.TaskReply.node_id)
  return _s;
}
inline const ::std::string& TaskReply::_internal_node_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_id_.Get();
}
inline void TaskReply::_internal_set_node_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TaskReply::_internal_mutable_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.node_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TaskReply::release_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:orion.TaskReply.node_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.node_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.node_id_.Set("", GetArena());
  }
  return released;
}
inline void TaskReply::set_allocated_node_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.node_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.node_id_.IsDefault()) {
    _impl_.node_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.TaskReply.node_id)
}

// -------------------------------------------------------------------

// ObjectReport

// string object_id = 1;
inline void ObjectReport::clear_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.object_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ObjectReport::object_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:orion.ObjectReport.object_id)
  return _internal_object_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ObjectReport::set_object_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.object_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:orion.ObjectReport.object_id)
}
inline ::std::string* PROTOBUF_NONNULL ObjectReport::mutable_object_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:orion.ObjectReport.object_id)
  return _s;
}
inline const ::std::string& ObjectReport::_internal_object_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.object_id_.Get();
}
inline void ObjectReport::_internal_set_object_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.object_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ObjectReport::_internal_mutable_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.object_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ObjectReport::release_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:orion.ObjectReport.object_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.object_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.object_id_.Set("", GetArena());
  }
  return released;
}
inline void ObjectReport::set_allocated_object_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.object_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.object_id_.IsDefault()) {
    _impl_.object_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.ObjectReport.object_id)
}

// string node_id = 2;
inline void ObjectReport::clear_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& ObjectReport::node_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:orion.ObjectReport.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ObjectReport::set_node_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:orion.ObjectReport.node_id)
}
inline ::std::string* PROTOBUF_NONNULL ObjectReport::mutable_node_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:orion.ObjectReport.node_id)
  return _s;
}
inline const ::std::string& ObjectReport::_internal_node_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_id_.Get();
}
inline void ObjectReport::_internal_set_node_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ObjectReport::_internal_mutable_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.node_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ObjectReport::release_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:orion.ObjectReport.node_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.node_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.node_id_.Set("", GetArena());
  }
  return released;
}
inline void ObjectReport::set_allocated_node_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.node_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.node_id_.IsDefault()) {
    _impl_.node_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.ObjectReport.node_id)
}

// -------------------------------------------------------------------

// ObjectLocationRequest

// string object_id = 1;
inline void ObjectLocationRequest::clear_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.object_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ObjectLocationRequest::object_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:orion.ObjectLocationRequest.object_id)
  return _internal_object_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ObjectLocationRequest::set_object_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.object_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:orion.ObjectLocationRequest.object_id)
}
inline ::std::string* PROTOBUF_NONNULL ObjectLocationRequest::mutable_object_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:orion.ObjectLocationRequest.object_id)
  return _s;
}
inline const ::std::string& ObjectLocationRequest::_internal_object_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.object_id_.Get();
}
inline void ObjectLocationRequest::_internal_set_object_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.object_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ObjectLocationRequest::_internal_mutable_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.object_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ObjectLocationRequest::release_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:orion.ObjectLocationRequest.object_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.object_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.object_id_.Set("", GetArena());
  }
  return released;
}
inline void ObjectLocationRequest::set_allocated_object_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.object_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.object_id_.IsDefault()) {
    _impl_.object_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.ObjectLocationRequest.object_id)
}

// -------------------------------------------------------------------

// ObjectLocationReply

// string node_id = 1;
inline void ObjectLocationReply::clear_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ObjectLocationReply::node_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:orion.ObjectLocationReply.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ObjectLocationReply::set_node_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:orion.ObjectLocationReply.node_id)
}
inline ::std::string* PROTOBUF_NONNULL ObjectLocationReply::mutable_node_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:orion.ObjectLocationReply.node_id)
  return _s;
}
inline const ::std::string& ObjectLocationReply::_internal_node_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_id_.Get();
}
inline void ObjectLocationReply::_internal_set_node_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ObjectLocationReply::_internal_mutable_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.node_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ObjectLocationReply::release_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:orion.ObjectLocationReply.node_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.node_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.node_id_.Set("", GetArena());
  }
  return released;
}
inline void ObjectLocationReply::set_allocated_node_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.node_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.node_id_.IsDefault()) {
    _impl_.node_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.ObjectLocationReply.node_id)
}

// string address = 2;
inline void ObjectLocationReply::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& ObjectLocationReply::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:orion.ObjectLocationReply.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ObjectLocationReply::set_address(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:orion.ObjectLocationReply.address)
}
inline ::std::string* PROTOBUF_NONNULL ObjectLocationReply::mutable_address()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:orion.ObjectLocationReply.address)
  return _s;
}
inline const ::std::string& ObjectLocationReply::_internal_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.address_.Get();
}
inline void ObjectLocationReply::_internal_set_address(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ObjectLocationReply::_internal_mutable_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.address_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ObjectLocationReply::release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:orion.ObjectLocationReply.address)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.address_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.address_.Set("", GetArena());
  }
  return released;
}
inline void ObjectLocationReply::set_allocated_address(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.ObjectLocationReply.address)
}

// -------------------------------------------------------------------

// ObjectData

// string object_id = 1;
inline void ObjectData::clear_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.object_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ObjectData::object_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:orion.ObjectData.object_id)
  return _internal_object_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ObjectData::set_object_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.object_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:orion.ObjectData.object_id)
}
inline ::std::string* PROTOBUF_NONNULL ObjectData::mutable_object_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:orion.ObjectData.object_id)
  return _s;
}
inline const ::std::string& ObjectData::_internal_object_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.object_id_.Get();
}
inline void ObjectData::_internal_set_object_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.object_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ObjectData::_internal_mutable_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.object_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ObjectData::release_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:orion.ObjectData.object_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.object_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.object_id_.Set("", GetArena());
  }
  return released;
}
inline void ObjectData::set_allocated_object_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.object_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.object_id_.IsDefault()) {
    _impl_.object_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.ObjectData.object_id)
}

// bytes data = 2;
inline void ObjectData::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& ObjectData::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:orion.ObjectData.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ObjectData::set_data(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:orion.ObjectData.data)
}
inline ::std::string* PROTOBUF_NONNULL ObjectData::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:orion.ObjectData.data)
  return _s;
}
inline const ::std::string& ObjectData::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void ObjectData::_internal_set_data(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ObjectData::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ObjectData::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:orion.ObjectData.data)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.data_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.data_.Set("", GetArena());
  }
  return released;
}
inline void ObjectData::set_allocated_data(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.ObjectData.data)
}

// -------------------------------------------------------------------

// Empty

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace orion


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // orion_2eproto_2epb_2eh
